MICRO
m00 00000 000 000 111 000 011 0000 0100 00 0 1 1 1 0 1 0 1 1 1	// Bootstrap
m01 00000 000 000 000 000 001 0000 0000 00 0 0 1 0 0 0 0 0 0 0

m02 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >>>> PC++ >> BEGIN OF LOAD
m03 00000 000 000 111 000 011 0000 1001 00 0 1 1 0 0 1 1 1 0 1  >> MDR + 0 -> X
m04 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >> PC++
m05 00000 000 000 111 000 001 0000 0000 00 0 1 1 1 0 1 1 1 0 1  >> MDR + 0 -> MAR
m06 00000 000 000 100 000 001 1001 0000 00 0 1 1 0 0 1 1 1 1 0  >> X + 0 -> NOP, SELB=1
m07 00000 000 000 111 000 011 0000 0000 00 0 0 1 0 0 1 1 1 0 1  >> MDR + 0 -> Feedback Reg, RAMF
m08 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >> PC++
m09 00000 000 000 000 000 001 0000 0000 00 0 0 1 0 0 0 1 1 1 1  >>>> Next(PC) >> END OF LOAD

m0a 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >>>> PC++ >> BEGIN OF STORE
m0b 00000 000 000 111 000 011 0000 1001 00 0 1 1 0 0 1 1 1 0 1  >> MDR + 0 -> X
m0c 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >> PC++
m0d 00000 000 000 111 000 001 0000 0000 00 0 1 1 1 0 1 1 1 0 1  >> MDR + 0 -> MAR
m0e 00000 000 000 100 000 001 1001 0000 00 0 1 1 0 0 1 1 1 1 0  >> X + 0 -> NOP
m0f 00000 000 000 011 000 001 0000 0000 00 0 0 0 0 0 1 1 1 1 1	>> portB + 0 -> MDR, MWE~, SELB = 0
m10 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >> PC++
m11 00000 000 000 000 000 001 0000 0000 00 0 0 1 0 0 0 1 1 1 1  >>>> Next(PC) >> END OF STORE

m12 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >>>> PC++ >> BEGIN OF ADD R1, $K
m13 00000 000 000 111 000 011 0000 1001 00 0 1 1 0 0 1 1 1 0 1  >> MDR + 0 -> X
m14 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >> PC++
m15 00000 000 000 111 000 001 0000 0000 00 0 1 1 1 0 1 1 1 0 1  >> MDR + 0 -> MAR
m16 00000 000 000 100 000 001 1001 0000 00 0 1 1 0 0 1 1 1 1 0  >> X + 0 -> NOP
m17 00000 000 000 011 000 000 0000 0000 00 0 0 1 0 0 1 1 1 1 0  >> Bport + 0 -> Q (000)
m18 00000 000 000 100 000 001 1001 0000 00 0 1 1 0 0 1 1 1 1 0  >> X + 0 -> NOP	
m19 00000 000 000 110 000 011 0000 0000 00 0 0 1 0 0 1 1 1 0 1  >> MDR + Q -> Bport 
m1a 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >> PC++
m1b 00000 000 000 000 000 001 0000 0000 00 0 0 1 0 0 0 1 1 1 1  >>>> Next(PC) >> END OF ADD R1, $K

m1c 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >>>> PC++ >> BEGIN OF SUB R1, $K
m1d 00000 000 000 111 000 011 0000 1001 00 0 1 1 0 0 1 1 1 0 1  >> MDR + 0 -> X (R)
m1e 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >> PC++
m1f 00000 000 000 111 000 001 0000 0000 00 0 1 1 1 0 1 1 1 0 1  >> MDR + 0 -> MAR
m20 00000 000 000 100 000 001 1001 0000 00 0 1 1 0 0 1 1 1 1 0  >> X + 0 -> NOP
m21 00000 000 000 011 000 000 0000 0000 00 0 0 1 0 0 1 1 1 1 0  >> Bport + 0 -> Q (000) (periexomeno R)
m22 00000 000 000 100 000 001 1001 0000 00 0 1 1 0 0 1 1 1 1 0  >> X + 0 -> NOP	
m23 00000 000 000 110 001 011 0000 0000 00 0 0 1 0 0 1 1 1 0 1  >> Q - MDR -> Bport (S-R) 
m24 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >> PC++
m25 00000 000 000 000 000 001 0000 0000 00 0 0 1 0 0 0 1 1 1 1  >>>> Next(PC) >> END OF SUB R1, $K

m26 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >>>> PC++ ( get R1 ) >> BEGIN OF ADD R1, R2
m27 00000 000 000 111 000 011 0000 1001 00 0 1 1 0 0 1 1 1 0 1  >> MDR + 0 -> X = R1
m28 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >> PC++ ( get R2 )
m29 00000 000 000 111 000 001 0000 0000 00 0 1 1 0 0 1 1 1 0 1  >> MDR + 0 -> NOP 
m2a 00000 000 000 011 000 000 0000 0000 00 0 0 1 0 0 1 1 1 1 0  >> Bport + 0 -> Q ( Q holds R2's value )
m2b 00000 000 000 010 000 011 0000 1010 00 0 1 1 0 0 1 1 1 1 1  >> Q + 0 -> Y == R2's value
m2c 00000 000 000 100 000 001 1001 0000 00 0 1 1 0 0 1 1 1 1 0  >> X + 0 -> NOP
m2d 00000 000 000 001 000 011 1010 0000 00 0 0 1 0 0 1 1 1 1 0  >> Bport + Y -> Bport -> R1 += R2
m2e 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >> PC++
m2f 00000 000 000 000 000 001 0000 0000 00 0 0 1 0 0 0 1 1 1 1  >>>> Next(PC) >> END OF ADD R1, R2

m30 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >>>> PC++ >> BEGIN OF SHL R
m31 00000 000 000 111 000 001 0000 0000 00 0 1 1 0 0 1 1 1 0 1  >> MDR + 0 -> NOP (8elw feedback meta)
m32 00000 000 000 011 000 111 0000 0000 00 0 0 1 0 0 1 1 1 1 1  >> SHLA enable (X), SELB=0
m33 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >> PC++
m34 00000 000 000 000 000 001 0000 0000 00 0 0 1 0 0 0 1 1 1 1  >>>> Next(PC) >> END OF SHL R

m35 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >>>> PC++ >> BEGIN OF DEC
m36 00000 000 000 111 000 011 0000 1001 00 0 1 1 0 0 1 1 1 0 1  >> MDR + 0 -> X (R)
m37 00000 000 000 100 000 001 1001 0000 00 0 1 1 0 0 1 1 1 1 0  >> X + 0 -> NOP (8elw feedback meta)
m38 00000 000 000 011 000 000 0000 0000 00 0 0 1 0 0 1 1 1 1 0  >> Bport + 0 -> Q ( Q holds R's value )
m39 00000 000 000 100 000 001 1001 0000 00 0 1 1 0 0 1 1 1 1 0  >> X + 0 -> NOP
m3a 00000 000 000 110 001 011 0000 0000 01 0 0 1 0 0 1 1 1 1 0  >> Q - 1 -> Bport
m3b 00000 000 000 101 000 011 0100 0100 01 0 1 1 1 0 1 1 1 1 0  >> PC++
m3c 00000 000 000 000 000 001 0000 0000 00 0 0 1 0 0 0 1 1 1 1  >>>> Next(PC) >> END OF DEC

m3d 00000 000 000 100 000 011 0100 0100 00 0 0 1 0 0 1 1 1 1 1  >> PC + 0 -> PC ## HALT
m3e 00000 000 000 001 000 001 0000 0000 00 0 1 1 0 0 0 1 1 1 1  >> Next(PC)


MAPPER
m00 02 LOAD R, $K
m01 0a STORE R, $K
m02 12 ADD R1, $K
m03 1c SUB R1, $K
m04 26 ADD R1, R2
m05 30 SHL R
m06 35 DEC R
m07 3d HALT

MAIN
m00 00 LOAD opcode 
m01 0b R1
m02 f0 X
m03 02 ADD R1,$K opcode
m04 0b R1
m05 f1 Y
m06 03 SUB opcode
m07 0b R1
m08 f2 Z
m09 06 DEC opcode
m0a 0b R1
m0b 05 SHL R1
m0c 0b R1
m0d 05 SHL R1
m0e 0b R1
c R1 = 4*( X + Y - Z )
m0f 00 LOAD opcode 
m10 0c R2
m11 f0 X
m12 02 ADD R2,$K opcode
m13 0c R2
m14 f1 Y
m15 06 DEC opcode
m16 0c R2
m17 05 SHL R2
m18 0c R2 
c R2 = 2*( X + Y - 1 )
m19 04 ADD R1,R2
m1a 0b R1  Storing result to R1
m1b 0c R2
c Storing the Result..
m1c 01 STORE R1, $K opcode
m1d 0b R1
m1e f3 W=Result
c Job Done. Will halt now.
m1f 07 HALT opcode
c Data Segment
mf0 05 X
mf1 03 Y
mf2 06 Z
mf3 00 W